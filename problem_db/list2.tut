#{Text}#
<h3>Constructing a List from Another List</h3>
One typical kind of list processing is to construct a list from information
in another list. This is typically done by iterating over the input list using
a for loop and building up the result in another list.
<p>
Write a function definition of <tt>all_gt</tt>
that takes a list of numbers, say <tt>nums</tt>, and a number, say <tt>n</tt> and returns the list of numbers from <tt>nums</tt> that are greater than
<tt>n</tt>. The order of elements should be preserved. 

<p>For example:
<br><tt>all_gt([1,2,3,4], 2) => [3,4]</tt>
<br><tt>all_gt([1,2,3,4], 4) => []</tt>

#{Hint}#
Start by initializing the result to the empty list.
#{Hint}#
Use append.














#{TestCode}#
#{preload}#
def all_gt(nums, n):
    """Return the list of all numbers from nums that are bigger than n.

    all_gt(list<number>, number) -> list<number>
    """
    # add your code here

#{global}#
import random,compiler
class CodeVisitor:
    def __init__(self):
        self.arg1 = None
        self.for_iter = None
        self.in_defn = False
        self.in_for = False
        self.has_return = False
        self.assign = None
        self.assign_match = False
        self.append = False
        self.in_assign = False
        self.append_in_assign = False
        self.is_defined = False
        
    def visitFunction(self,t):
        if t.name == 'all_gt':
            self.is_defined = True
            self.in_defn = True
            if len(t.argnames) == 2:
                self.arg1 = t.argnames[0]
            for n in t.getChildNodes():
                compiler.walk(n, self)               
            self.in_defn = False
            
    def visitFor(self,t):
        if self.in_defn:
            self.in_for = True
            if t.getChildNodes()[1].__class__ == compiler.ast.Name:
                self.for_iter = t.getChildNodes()[1].name
        for n in t.getChildNodes():
            compiler.walk(n, self)
            
    def visitCallFunc(self, t):
        child = t.getChildNodes()[0]
        if not self.append and \
           child.__class__ == compiler.ast.Getattr and \
           child.attrname == 'append':
            self.append = True
            self.append_in_assign = self.in_assign
            if child.expr.__class__ == compiler.ast.Name:
                self.assign_match = child.expr.name == self.assign

    def visitAssign(self,t):
        if self.in_defn and not self.assign and not self.in_for:
            self.assign = t.getChildNodes()[0].name
        self.in_assign = True
        for n in t.getChildNodes():
            compiler.walk(n, self)
        self.in_assign = False
            
        
            
    def visitReturn(self,t):
        self.has_return = True
        
#{test}#
#{code}#
ast = compiler.parse(user_text)
visitor = CodeVisitor()
compiler.walk(ast, visitor)
if not visitor.is_defined:
    print_error('There is no definition of all_gt')
elif not visitor.in_for:
    print_error('Your function definition does not contain a for loop.')
elif not visitor.has_return:
    print_error('You need a return statement')
elif not visitor.assign:
    print_error("You did't initialize before the for loop")
elif visitor.append_in_assign:
    print_error("Do not use append in an assign statement - append modifies the list 'inline'")
elif not visitor.assign_match:
    print_warning("Try using append in the for loop to update your result variable")
elif visitor.arg1 != visitor.for_iter:
    print_warning('Your for loop should iterate over %s ' % visitor.arg1)


#{test}#
#{code}#
try:
    result = all_gt([], 3)
    ok = True
except Exception as e:
    print_exception(e)
    ok = False
if not ok:
    pass
elif type(result) != type([]):
    print_error('Wrong: The result should be a list - you got %s' % repr(result))
elif result != []:
    print_error('Wrong: the empty list has no big elements')

#{test}#
#{start}#
choices = [([1,2,3,4,5,6,7,8], 9), ([2,7,9,21,64], 100), ([2,2,3,3,7,7,9,9,9],10)]
inums, n = random.choice(choices)
#{init}#
nums = list(inums)
#{code}#
answer = [x for x in inums if x>n]
try:
    result = all_gt(nums, n)
    ok = True
except Exception as e:
    print_exception(e)
    ok = False
if not ok:
    pass
elif type(result) != type([]):
    print_error('Wrong: The result should be a list - you got %s' % repr(result))
elif result != answer:
    print_error('Wrong: all_gt(%s, %d) should return %s you got %s' % (str(nums), n, str(answer), repr(result)))
elif nums != inums:
    print_error('Wrong: you have modified the input list')
#{test}#
#{start}#
choices = [([1,2,3,4,5,6,7,8], 0), ([2,7,9,21,64], 63), ([2,2,3,3,7,7,9,9,9],3)]
inums, n = random.choice(choices)
#{init}#
nums = list(inums)
#{code}#
answer = [x for x in inums if x>n]
try:
    result = all_gt(nums, n)
    ok = True
except Exception as e:
    print_exception(e)
    ok = False
if not ok:
    pass
elif type(result) != type([]):
    print_error('Wrong: The result should be a list - you got '+str(result))
elif result != answer:
    print_error('Wrong: all_gt(%s, %d) should return %s you got %s' % (str(nums), n, str(answer), repr(result)))
elif nums != inums:
    print_error('Wrong: you have modified the input list')
else:
    correct()














